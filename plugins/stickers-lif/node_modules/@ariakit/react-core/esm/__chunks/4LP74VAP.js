import {
  useEvent,
  useLiveRef,
  useSafeLayoutEffect
} from "./J7Q2EO23.js";
import {
  __spreadProps,
  __spreadValues
} from "./PNRLI7OV.js";

// src/utils/store.tsx
import * as React from "react";
import { hasOwnProperty, identity } from "@ariakit/core/utils/misc";
import { init, subscribe, sync } from "@ariakit/core/utils/store";
import { flushSync } from "react-dom";
import useSyncExternalStoreExports from "use-sync-external-store/shim/index.js";
var { useSyncExternalStore } = useSyncExternalStoreExports;
var noopSubscribe = () => () => {
};
var inFlushSyncContext = false;
function safeFlushSync(fn, canFlushSync = true) {
  if (inFlushSyncContext || !canFlushSync) {
    fn();
    return;
  }
  inFlushSyncContext = true;
  const originalError = console.error;
  if (process.env.NODE_ENV !== "production") {
    console.error = (...data) => {
      if (typeof data[0] === "string" && data[0].startsWith("Warning: flushSync")) {
        return;
      }
      originalError(...data);
    };
  }
  try {
    flushSync(fn);
  } finally {
    console.error = originalError;
    inFlushSyncContext = false;
  }
}
function useStoreState(store, keyOrSelector = identity) {
  const storeSubscribe = React.useCallback(
    (callback) => {
      if (!store)
        return noopSubscribe();
      return subscribe(store, null, callback);
    },
    [store]
  );
  const getSnapshot = () => {
    const key = typeof keyOrSelector === "string" ? keyOrSelector : null;
    const selector = typeof keyOrSelector === "function" ? keyOrSelector : null;
    const state = store == null ? void 0 : store.getState();
    if (selector)
      return selector(state);
    if (!state)
      return;
    if (!key)
      return;
    if (!hasOwnProperty(state, key))
      return;
    return state[key];
  };
  return useSyncExternalStore(storeSubscribe, getSnapshot, getSnapshot);
}
function useStoreProps(store, props, key, setKey) {
  const value = hasOwnProperty(props, key) ? props[key] : void 0;
  const setValue = setKey ? props[setKey] : void 0;
  const propsRef = useLiveRef({ value, setValue });
  const canSyncValue = React.useRef(true);
  useSafeLayoutEffect(() => {
    let canFlushSync = false;
    queueMicrotask(() => {
      canFlushSync = true;
    });
    return sync(store, [key], (state, prev) => {
      const { value: value2, setValue: setValue2 } = propsRef.current;
      if (!setValue2)
        return;
      if (state[key] === prev[key])
        return;
      if (state[key] === value2)
        return;
      if (!canFlushSync) {
        canSyncValue.current = false;
        queueMicrotask(() => {
          canSyncValue.current = true;
        });
      }
      safeFlushSync(() => setValue2(state[key]), canFlushSync);
    });
  }, [store, key]);
  useSafeLayoutEffect(() => {
    if (value === void 0)
      return;
    canSyncValue.current = true;
    return sync(store, [key], () => {
      if (!canSyncValue.current)
        return;
      store.setState(key, value);
    });
  }, [store, key, value]);
}
function useStore(createStore, props) {
  const [store, setStore] = React.useState(() => createStore(props));
  useSafeLayoutEffect(() => init(store), [store]);
  const useState2 = React.useCallback(
    (keyOrSelector) => useStoreState(store, keyOrSelector),
    [store]
  );
  const memoizedStore = React.useMemo(
    () => __spreadProps(__spreadValues({}, store), { useState: useState2 }),
    [store, useState2]
  );
  const updateStore = useEvent(() => {
    setStore((store2) => createStore(__spreadValues(__spreadValues({}, props), store2.getState())));
  });
  return [memoizedStore, updateStore];
}

export {
  useStoreState,
  useStoreProps,
  useStore
};
